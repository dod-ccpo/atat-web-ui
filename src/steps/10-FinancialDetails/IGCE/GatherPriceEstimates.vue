<template>
  <v-form ref="form" lazy-validation>
  <v-container fluid class="container-max-width _anticipated-users-accordion">
    <v-row>
      <v-col class="col-12">
        <h1 class="page-header mb-3">
          Let’s work on price estimates for your performance requirements
        </h1>
        <p class="page-paragraph mb-10">
          Using the report generated from the previous screen, specify the
          projected price for each of your cloud service and support
          requirements. Edit any pre-filled details, as needed, to provide a
          more accurate description of what you are estimating (e.g., specific
          product/service names or configuration summaries generated by CSP
          calculator). We’ll use this info to populate total projected prices
          for each period of your task order later.
          <a
            role="button"
            id="OpenLearnMore"
            tabindex="0"
            @click="openSlideoutPanel"
            @keydown.enter="openSlideoutPanel"
            @keydown.space="openSlideoutPanel"
          >
            View Price Estimate FAQs
          </a>
        </p>
        <div class="_price-estimates-accordion">
          <v-expansion-panels
           
            v-for="(value, name, index) in estimateDataSource"
            :id="'AnticipatedUserAndDataNeedsAccordion' + index"
            :key="index"
            class="mb-4"
            borderless
            multiple
            :model-value="isPanelOpen"
          >
            <v-expansion-panel>
              <v-expansion-panel-title>
                <div class="d-flex">
                  <div class="h4 _expansion-panel-header">
                    {{ name }}
                  </div>
                  <div class="offering-number">
                    {{ value.length }}
                  </div>
                </div>
              </v-expansion-panel-title>
              <v-expansion-panel-text>
                <div>
                  <div class="_expansion-panel-content-header">
                    <div class="summary-text">Service Name and Configuration Summary</div>
                    <div class="estimate-price-text">Estimated price per unit</div>
                  </div>
                  <Card_Requirement
                    v-for="(requirement, idx) in value"
                    :cardData="value[idx]"
                    :key="idx"
                    :index="idx + 1"
                  />
                </div>
              </v-expansion-panel-text>
            </v-expansion-panel>
          </v-expansion-panels>
        </div>
      </v-col>
    </v-row>
  </v-container>
  </v-form>
</template>


<script lang="ts">
import { Component, Vue, toNative } from "vue-facing-decorator";
import SlideoutPanel from "@/store/slideoutPanel";
import {
  SlideoutPanelContent,
} from "../../../../types/Global";
// eslint-disable-next-line camelcase
/* eslint-disable camelcase */
import SlideOut_GatherPricesEstimates from 
  "@/steps/10-FinancialDetails/IGCE/components/SlideOut_GatherPricesEstimates.vue";
import Card_Requirement from "@/steps/10-FinancialDetails/IGCE/components/Card_Requirement.vue";
import IGCE from "@/store/IGCE";
import SaveOnLeave from "@/mixins/saveOnLeave";
import AcquisitionPackage from "@/store/acquisitionPackage";
import { CrossDomainSolutionDTO, IgceEstimateDTO, ReferenceColumn } from "@/api/models";
import ClassificationRequirements from "@/store/classificationRequirements";
import Periods from "@/store/periods";
import { ComponentPublicInstance } from "vue";

@Component({
  mixins: [SaveOnLeave],
  components: { 
    Card_Requirement
  },
})
class GatherPriceEstimates extends Vue {
  $refs!: {
    form: ComponentPublicInstance & { validate: () => boolean};
  }

  igceEstimateData: IgceEstimateDTO[] = [];
  tempEstimateDataSource: IgceEstimateDTO[][] = [];
  estimateDataSource: IgceEstimateDTO[][] = [];
  classLevels = ClassificationRequirements.selectedClassificationLevels;
  cdsClassifications = ClassificationRequirements.cdsSolution?.selected_periods
  isPanelOpen = [0]; //0 is open; 1 is closed.
  cdsSNOWRecord: CrossDomainSolutionDTO|null|undefined ;

  get Form(): ComponentPublicInstance & { validate: () => boolean } {
    return this.$refs.form as ComponentPublicInstance & { validate: () => boolean };
  }

  public openSlideoutPanel(e: Event): void {
    if (e && e.currentTarget) {
      const opener = e.currentTarget as HTMLElement;
      SlideoutPanel.openSlideoutPanel(opener.id);
    }
  }

  async loadOnEnter(): Promise<void> {
    await IGCE.loadIgceEstimateByPackageId(AcquisitionPackage.packageId);
    await this.createDataSource();
  }

  async createDataSource(): Promise<void>{
    //filter out useless cds records
    this.igceEstimateData = await IGCE.igceEstimateList.filter(
      iel => iel.title?.toLowerCase().indexOf("cross domain") === -1
    )
    await this.populateClassificationDisplay();
    await this.groupByClassificationDisplay();
    await this.sortDataSource();
    await this.addCDSEntry();
    this.estimateDataSource = await this.tempEstimateDataSource;
  }

  // prep data source - populate classification_display attrib 
  async populateClassificationDisplay(): Promise<void>{
    await this.igceEstimateData.forEach((est)=>{
      const classLevelSysId = (est.classification_level as ReferenceColumn).value as string;
      const level = ClassificationRequirements.classificationLevels.find(
        (level) => {
          return classLevelSysId && level.sys_id === classLevelSysId
        })
      est.classification_display = level?.display || "";
    })
  }
  
  // group by classification_display attrib
  async groupByClassificationDisplay(): Promise<void> {
    this.tempEstimateDataSource = await this.igceEstimateData.filter(
      estimate => estimate.classification_level !== ""
    ).reduce(function (acc, current) {
      acc[current.classification_display || ""] = acc[current.classification_display || ""] || [];
      acc[current.classification_display || ""].push(current);
      return acc;
    }, Object.create(null));
  }

  public async createPopString(): Promise<string> {
    const selectedPeriods: Record<string, string> = {}

    if(this.cdsClassifications){
      const selectedCDSPeriods = this.cdsClassifications?.split(",")
      selectedCDSPeriods.forEach((cds)=>{
        Periods.periods.forEach(period => {
          const sysId = period.sys_id
          if(cds === sysId){
            selectedPeriods[sysId] = period.period_unit_count
          }
        })
      })
    }else{
      Periods.periods.forEach(period => {
        const sysId = period.sys_id
        if(sysId){
          selectedPeriods[sysId] = period.period_unit_count
        }
      })
    }
    return JSON.stringify(selectedPeriods)
  }

  async addCDSEntry():Promise<void>{
    this.cdsSNOWRecord = await IGCE.getCDSRecord();
    if(this.cdsSNOWRecord?.cross_domain_solution_required !== "YES"
      || ClassificationRequirements.cdsSolution === null){
      return;
    }
    const existingCDSIGCERecord = await IGCE.igceEstimateList.find(
      ied => ied.title?.toLowerCase().indexOf("cross domain") !== -1
    )
    const existingClassLevels = Object.keys(this.tempEstimateDataSource);
    const doesTSExist = existingClassLevels.includes("Top Secret");
    const doesSecretExist = existingClassLevels.includes("Secret - IL6") && !doesTSExist;
    const cdsTransfers = this.cdsSNOWRecord?.traffic_per_domain_pair !== undefined  
      ? JSON.parse(this.cdsSNOWRecord?.traffic_per_domain_pair)
      : undefined
    let hasTSTransfer = false
    let hasSTransfer = false
    let classificationLvl = ""
    if(cdsTransfers){
      cdsTransfers.forEach((transfer:any) => {
        const values = transfer.type.split("_")
        const includesTS = values.includes('TS')
        const includesS = values.includes('S')
        if(!hasTSTransfer && includesTS){
          hasTSTransfer = true
        }
        if(!hasSTransfer && includesS){
          hasSTransfer = true
        }
      })
    }
    if(hasTSTransfer){
      const topSecret = this.classLevels.find((cl)=>{
        return cl.classification === "TS"
      })
      classificationLvl = typeof topSecret?.classification_level === "object"?
        topSecret?.classification_level.value as string
        :topSecret?.classification_level as string
    }
    if(hasSTransfer && !hasTSTransfer){
      const secret = this.classLevels.find((cl)=>{
        return cl.classification === "S"
      })
      classificationLvl = typeof secret?.classification_level === "object"?
        secret?.classification_level.value as string
        :secret?.classification_level as string
    }
    const blankRecord = {
      title: "Cross Domain Solution (CDS)",
      description: await this.formatCDSDescription(),
      unit: "MONTH", 
      unit_price: 0,
      unit_quantity: await this.createPopString(),
      cross_domain_solution: this.cdsSNOWRecord?.sys_id,
      cross_domain_pair: this.cdsSNOWRecord?.traffic_per_domain_pair,
      acquisition_package: AcquisitionPackage.packageId,
      classification_display:  "",
      classification_instance: "",
      classification_level: classificationLvl,
      idiq_clin_type: "CLOUD",
    }
    if(existingCDSIGCERecord){
      existingCDSIGCERecord.classification_level = classificationLvl
      existingCDSIGCERecord.unit_quantity = await this.createPopString()
      existingCDSIGCERecord.idiq_clin_type = "CLOUD"
    }
    const cdsRecord = existingCDSIGCERecord !== undefined 
      ? existingCDSIGCERecord
      : blankRecord



    // add item to the highest class level 
    for (const classLevel in this.tempEstimateDataSource){
      if (doesTSExist && classLevel === "Top Secret"){
        this.tempEstimateDataSource[classLevel].push(cdsRecord)
      }
      if (doesSecretExist && classLevel === "Secret - IL6"){
        this.tempEstimateDataSource[classLevel].push(cdsRecord)
      }
    }
  }

  async formatCDSDescription(): Promise<string>{
    if (this.cdsSNOWRecord){
      const pairs = JSON.parse(this.cdsSNOWRecord?.traffic_per_domain_pair || "");
      let desc = "";
      pairs.forEach(
        (p:  Record<string, string> ) =>{
          desc += p.type.toLowerCase().replaceAll("_", " ")
            .replaceAll("ts", "Top Secret") 
            .replaceAll("s", "Secret")
            .replaceAll("u", "Unclassified")
          desc += " (" + p.dataQuantity + " GB/month), "
        })
      return desc.substring(0,desc.lastIndexOf(","));
    }
    return "";
  }

  async sortDataSource(): Promise<void>{
    // sort nested arrays
    for (const classLevelsArray in this.tempEstimateDataSource){
      this.tempEstimateDataSource[classLevelsArray].sort(
        (a, b) => ((a.title ?? '') > (b.title ?? '')) ? 1 : -1 
      )
    }
  }

  public async mounted(): Promise<void> {
    await this.loadOnEnter();
    const slideoutPanelContent: SlideoutPanelContent = {
      // eslint-disable-next-line camelcase
      component: SlideOut_GatherPricesEstimates,
      title: "Learn More",
    };
    await SlideoutPanel.setSlideoutPanelComponent(slideoutPanelContent);
  }

  protected async saveOnLeave(): Promise<boolean> {
    if (document.getElementsByClassName("field-error").length === 0){
      await AcquisitionPackage.setValidateNow(true);
      try {
        await IGCE.setCostEstimate(this.estimateDataSource);
        await IGCE.setIgceEstimate(this.igceEstimateData);
      } catch (error) {
        console.log(error);
      }
      return true;
    }
    return false;
  }
}

export default GatherPriceEstimates
</script>

