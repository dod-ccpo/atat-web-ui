<template>
  <div>
    <h1 class="page-header">
      Let’s work on price estimates for your performance requirements
    </h1>
    <p class="page-paragraph">
      Using the report generated from the previous screen, specify the projected price for each of
      your cloud service and support requirements. Edit any pre-filled details, as needed, to
      provide a more accurate description of what you are estimating (e.g., specific product/service
      names or configuration summaries generated by CSP calculator). We’ll use this info to
      populate total projected prices for each period of your task order later.
      <a role="button"
         id="OpenLearnMore"
         tabindex="0"
         @click="openSlideoutPanel"
         @keydown.enter="openSlideoutPanel"
         @keydown.space="openSlideoutPanel">
        View Price Estimate FAQs
      </a>
    </p>
    <div class="_price-estimates-accordion">
      <v-expansion-panels
        v-model="accordionClosed[index]"
        v-for="(classification, index) in instanceData"
        :id="'AnticipatedUserAndDataNeedsAccordion' + index"
        :key="index"
        class="mb-4"
        flat
      >
        <v-expansion-panel expand>
          <v-expansion-panel-header>
            <div class="d-flex">
              <div class="h4 _expansion-panel-header">
                {{classification.labelShort}}
              </div>
              <div class="offering-number font-size-10">
                {{classification.offerings.length}}
              </div>
            </div>
          </v-expansion-panel-header>
          <v-expansion-panel-content>
            <div v-if="classification.offerings.length > 0">
              <div class="_expansion-panel-content-header">
                <div>
                  Service Name and Configuration Summary
                </div>
                <div>
                  Estimated price per unit
                </div>
              </div>

                <Card_Requirement
                  v-for="(requirement,idx) in classification.offerings"
                  :cardData="requirement"
                  :key="idx"
                  :index="idx + 1"
                />
            </div>
          </v-expansion-panel-content>
        </v-expansion-panel>
      </v-expansion-panels>
    </div>
  </div>
</template>
<script lang="ts">
import { Component, Mixins } from "vue-property-decorator";
import SlideoutPanel from "@/store/slideoutPanel";
import { OtherServiceOfferingData, SlideoutPanelContent } from "../../../../types/Global";
// eslint-disable-next-line camelcase
/* eslint-disable camelcase */
import SlideOut_GatherPricesEstimates
  from "@/steps/10-FinancialDetails/IGCE/components/SlideOut_GatherPricesEstimates.vue";
import { buildClassificationLabel, hasChanges } from "@/helpers";
import ClassificationRequirements from "@/store/classificationRequirements";
import { ReferenceColumn, SelectedClassificationLevelDTO } from "@/api/models";
import DescriptionOfWork from "@/store/descriptionOfWork";
import Card_Requirement from "@/steps/10-FinancialDetails/IGCE/components/Card_Requirement.vue";
import IGCE, { CostEstimate } from "@/store/IGCE";
import _ from "lodash";
import SaveOnLeave from "@/mixins/saveOnLeave";


@Component({
  components: {Card_Requirement}
})
export default class GatherPriceEstimates extends Mixins(SaveOnLeave) {

  public selectedClassifications: SelectedClassificationLevelDTO[] = []
  public accordionClosed: number[] = []
  public instanceData:CostEstimate[] = []

  public buildClassificationLabel = buildClassificationLabel
  public openSlideoutPanel(e: Event): void {
    if (e && e.currentTarget) {
      const opener = e.currentTarget as HTMLElement;
      SlideoutPanel.openSlideoutPanel(opener.id);
    }
  }
  public getFormattedNames(value: string): string {
    let avlOfferings = DescriptionOfWork.serviceOfferingGroups;
    const filtered = avlOfferings.filter(obj => obj.value == value);
    return filtered.length > 0 ? filtered[0].label : "";
  };

  public createFormData(serviceName: string, service: OtherServiceOfferingData) : string {
    switch (serviceName) {
    case "Compute":
      return service.numberOfInstances + " x ("
        + service.environmentType
        + ", "+ service.operatingEnvironment?.toLowerCase()+ ", "
        + service.operatingSystemAndLicensing+", "
        + service.numberOfVCPUs + " vCPUs, " + service.memoryAmount + " GB RAM, "
        + service.storageType?.toLowerCase()+" storage: "+ service.storageAmount+" "
        +service.storageUnit+", " + service.performanceTier+ ")"
    case "Database":
      return service.numberOfInstances + " x ("
          + service.databaseType
          + ", "+ service.operatingSystemAndLicensing +", " + service.databaseLicensing+", "
          + service.numberOfVCPUs + " vCPUs, " + service.memoryAmount + " GB RAM, "
          + service.storageType?.toLowerCase()+" storage: "+ service.storageAmount+" "
          +service.storageUnit+")"
    case "Storage":
      return service.numberOfInstances + " x ("
        + service.storageType?.toLowerCase()+" storage: "+ service.storageAmount+" "
        +service.storageUnit+")"
    default:
      return service.usageDescription ||
        service.descriptionOfNeed||""
    }
  }

  private get currentData(): CostEstimate[] {
    return _.cloneDeep(this.instanceData)
  }

  private savedData: CostEstimate[] = []


  private hasChanged(): boolean {
    return hasChanges(this.currentData, this.savedData);
  }

  private async loadOnEnter(): Promise<void> {
    const classifications = await ClassificationRequirements.getSelectedClassificationLevels()
    const cloudServices = DescriptionOfWork.cloudSupportServices
    this.selectedClassifications = classifications
      .sort((a,b) => a.impact_level > b.impact_level ? 1 : -1)
    this.savedData = IGCE.costEstimates
    if(this.savedData.length >= 1){
      //make changes to accommodate for returning after DOWObject has been changed
      this.instanceData = _.cloneDeep(this.savedData)
    }else{
      this.selectedClassifications.forEach((classification)=>{
        // eslint-disable-next-line camelcase
        const classification_instance: CostEstimate = {
          labelShort: buildClassificationLabel(classification,'short',true),
          sysId: typeof classification.classification_level === "object"
            ? (classification.classification_level as ReferenceColumn).value as string
            : classification.classification_level as string,
          offerings:[]
        }
        this.instanceData.push(classification_instance)
      })
      const dowObject = DescriptionOfWork.DOWObject
      dowObject.forEach((service)=>{
        const serviceName = this.getFormattedNames(service.serviceOfferingGroupId)
        if(service.otherOfferingData){
          service.otherOfferingData.forEach((offering)=>{
            if(offering.classificationLevel){
              this.instanceData.forEach((instance)=>{
                if(instance.sysId === offering.classificationLevel){
                  const classificationOfferings:{
                    IGCE_title:string,
                    IGCE_description:string,
                    monthly_price:string,
                    isCloudServicePackage:boolean,
                    sysId:string,
                  } = {
                    IGCE_title:"",
                    IGCE_description:"",
                    monthly_price:"",
                    isCloudServicePackage:false,
                    sysId:"",
                  }
                  if(offering.instanceNumber){
                    classificationOfferings.IGCE_title =
                      `${serviceName} - instance #${offering.instanceNumber}`;
                  }else{
                    classificationOfferings.IGCE_title = serviceName;
                  }
                  classificationOfferings.sysId = instance.sysId;
                  classificationOfferings.isCloudServicePackage = cloudServices
                    .includes(serviceName)
                  const formData = this.createFormData(serviceName,offering)
                  classificationOfferings.IGCE_description = formData || offering.usageDescription
                    ||""
                  if(serviceName !== 'Training'){
                    instance.offerings.push(classificationOfferings)
                  }
                }
              })
            }
          })
        }
        if(service.serviceOfferings){
          service.serviceOfferings.forEach((offering)=>{
            offering.classificationInstances?.forEach((classificationInstance)=>{
              this.instanceData.forEach((instance)=>{
                if(instance.sysId === classificationInstance.classificationLevelSysId){
                  const classificationOfferings:{
                    IGCE_title:string,
                    IGCE_description:string,
                    monthly_price:string,
                    isCloudServicePackage:boolean,
                    sysId:string,
                  } = {
                    IGCE_title:"",
                    IGCE_description:"",
                    monthly_price:"0",
                    isCloudServicePackage:false,
                    sysId:"",
                  }
                  classificationOfferings.IGCE_title = `${serviceName} - ${offering.name}`;
                  classificationOfferings.sysId = instance.sysId;
                  classificationOfferings.isCloudServicePackage = cloudServices
                    .includes(serviceName)
                  classificationOfferings.IGCE_description =
                    classificationInstance.anticipatedNeedUsage
                  if(serviceName !== 'Training'){
                    instance.offerings.push(classificationOfferings)
                  }
                }
              })
            })
          })
        }
      })
    }
    this.instanceData.forEach(instance=>{
      if(instance.offerings.length <= 0){
        this.accordionClosed.push(1)
      }else{
        this.accordionClosed.push(0)
      }
    })
  }
  protected async saveOnLeave(): Promise<boolean> {
    try{
      if (this.hasChanged()) {
        await IGCE.setCostEstimate(this.currentData)
      }
    }catch (error) {
      console.log(error);
    }
    return true;
  }


  public async mounted(): Promise<void> {
    await this.loadOnEnter()
    const slideoutPanelContent: SlideoutPanelContent = {
      // eslint-disable-next-line camelcase
      component: SlideOut_GatherPricesEstimates,
      title: "Learn More",
    };
    await SlideoutPanel.setSlideoutPanelComponent(slideoutPanelContent);
  }
}
</script>

